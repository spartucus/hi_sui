#!/usr/bin/env node
const os = require("node:os");
const fs = require("node:fs/promises");
const process = require("node:process");
const path = require("path");
const { spawn } = require("node:child_process");

const BUILD_DIR = path.join(__dirname, "../build");
const SRC_DIR = path.join(__dirname, "../src");
const CIRCOM_EXTENSION = ".circom";

async function main() {
  const args = cliArguments();
  const positionalArgs = Array.isArray(args._) ? args._ : [];

  const help = asBooleanFlag(args.help ?? args.h);
  const force = asBooleanFlag(args.force ?? args.f);
  const jobsRaw = args.jobs ?? args.j;
  let singleInputRaw = args.input ?? args.i;
  let inputDirRaw =
    args["input-dir"] ?? args.inputDir ?? args.inputs ?? args.I ?? args.d;
  let snarkjsOverride = args.snarkjs ?? args.s;

  if (singleInputRaw === true) {
    singleInputRaw = undefined;
  }
  if (inputDirRaw === true) {
    inputDirRaw = undefined;
  }
  if (snarkjsOverride === true) {
    snarkjsOverride = undefined;
  }

  if (!singleInputRaw && positionalArgs.length > 0) {
    const primaryPositional = positionalArgs[0];
    if (looksLikeJsonFile(primaryPositional)) {
      singleInputRaw = primaryPositional;
    } else if (!inputDirRaw) {
      inputDirRaw = primaryPositional;
    }
  }

  if (!inputDirRaw && positionalArgs.length > 1) {
    inputDirRaw = positionalArgs[1];
  }

  if (help) {
    console.log("Usage: ./scripts/generate_witness [OPTIONS]");
    console.log("Options:");
    console.log("  [input]             Positional shortcut for --input");
    console.log("  [inputDir]          Optional second positional for --input-dir");
    console.log("  --force             Regenerate witness files even if they exist");
    console.log("  --help              Show this help message");
    console.log("  --input <PATH>      Use the specified input JSON for all circuits");
    console.log("  --input-dir <DIR>   Search directory for per-circuit input JSON files");
    console.log("  --jobs, -j <N>      Number of parallel workers (default: CPU count)");
    console.log("  --snarkjs <PATH>    Explicit path to the snarkjs binary");
    process.exit(0);
  }

  if (!(await pathExists(SRC_DIR))) {
    console.log(`No circuits found. Directory '${SRC_DIR}' does not exist.`);
    return;
  }

  if (!(await pathExists(BUILD_DIR))) {
    console.log(
      `Build artifacts not found. Run './scripts/compile' before generating witnesses.`
    );
    return;
  }

  const circuits = await discoverCircuits(SRC_DIR);
  if (circuits.length === 0) {
    console.log(`No .circom files found under '${SRC_DIR}'.`);
    return;
  }

  const singleInput =
    typeof singleInputRaw === "string" && singleInputRaw.length > 0
      ? normalizePath(singleInputRaw)
      : undefined;
  if (singleInput && !(await pathExists(singleInput))) {
    throw new Error(`Input file '${singleInput}' does not exist.`);
  }

  const inputDir =
    typeof inputDirRaw === "string" && inputDirRaw.length > 0
      ? normalizePath(inputDirRaw)
      : undefined;
  if (inputDir && !(await pathExists(inputDir))) {
    throw new Error(`Input directory '${inputDir}' does not exist.`);
  }

  const snarkjsBin = await resolveSnarkjsBinary(snarkjsOverride);
  const parallelism = determineConcurrency(jobsRaw, circuits.length);

  console.log(
    `Preparing witness generation for ${circuits.length} circuit(s) with ${parallelism} parallel worker(s).`
  );

  const queue = circuits.map((circuitPath) => async () => {
    const relativePath = path.relative(SRC_DIR, circuitPath);
    const circuitDir = path.dirname(relativePath);
    const baseName = path.basename(relativePath, CIRCOM_EXTENSION);
    const outputDir = path.join(
      BUILD_DIR,
      circuitDir === "." ? "" : circuitDir
    );

    await fs.mkdir(outputDir, { recursive: true });

    const compiledMarker = path.join(
      outputDir,
      `${baseName}${CIRCOM_EXTENSION}.compiled`
    );
    if (!(await pathExists(compiledMarker))) {
      throw new Error(
        `Circuit '${relativePath}' has not been compiled yet. Run './scripts/compile'.`
      );
    }

    const wasmPath = path.join(
      outputDir,
      `${baseName}_js`,
      `${baseName}.wasm`
    );
    if (!(await pathExists(wasmPath))) {
      throw new Error(
        `Missing wasm file '${path.relative(process.cwd(), wasmPath)}'. Run './scripts/compile'.`
      );
    }

    const witnessPath = path.join(outputDir, `${baseName}.wtns`);
    if (!force && (await pathExists(witnessPath))) {
      console.log(`${relativePath} witness already generated`);
      return;
    }

    const inputPath = singleInput
      ? singleInput
      : await resolveInputPath({
          baseName,
          relativePath,
          outputDir,
          explicitInputDir: inputDir,
        });

    if (!inputPath) {
      throw new Error(
        `Unable to locate input JSON for '${relativePath}'. Provide one via --input or --input-dir.`
      );
    }

    console.log(`\nGENERATING WITNESS ${relativePath}`);

    const snarkjsArgs = [
      "wtns",
      "calculate",
      wasmPath,
      inputPath,
      witnessPath,
    ];

    await run(snarkjsBin, snarkjsArgs, { cwd: outputDir });

    console.log(`WITNESS GENERATED ${relativePath}`);
  });

  await processParallel(queue, parallelism);
}

void main().catch((error) => {
  if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error(error);
  }
  process.exit(1);
});

function cliArguments() {
  const argv = process.argv.slice(2);
  const result = {};
  const positional = [];

  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i];

    if (token.startsWith("--")) {
      const [rawKey, rawValue] = token.slice(2).split("=", 2);
      if (!rawKey) {
        continue;
      }

      if (rawValue !== undefined) {
        result[rawKey] = rawValue === "" ? true : rawValue;
        continue;
      }

      const next = argv[i + 1];
      if (next && !next.startsWith("-")) {
        result[rawKey] = next;
        i += 1;
      } else {
        result[rawKey] = true;
      }
      continue;
    }

    if (token.startsWith("-") && token.length > 1) {
      const rawKey = token.slice(1);
      const next = argv[i + 1];

      if (rawKey === "j") {
        if (next && !next.startsWith("-")) {
          result.jobs = next;
          i += 1;
        } else {
          result.jobs = true;
        }
        continue;
      }

      result[rawKey] = true;
      continue;
    }

    positional.push(token);
  }

  if (positional.length > 0) {
    result._ = positional;
  }

  return result;
}

function asBooleanFlag(value) {
  if (value === undefined) {
    return false;
  }

  if (value === true || value === false) {
    return value;
  }

  const normalized = String(value).trim().toLowerCase();
  if (
    normalized === "" ||
    normalized === "1" ||
    normalized === "true" ||
    normalized === "yes" ||
    normalized === "y"
  ) {
    return true;
  }

  if (
    normalized === "0" ||
    normalized === "false" ||
    normalized === "no" ||
    normalized === "n"
  ) {
    return false;
  }

  return true;
}

async function pathExists(targetPath) {
  try {
    await fs.access(targetPath);
    return true;
  } catch (error) {
    if (error && (error.code === "ENOENT" || error.code === "ENOTDIR")) {
      return false;
    }
    throw error;
  }
}

async function discoverCircuits(rootDir) {
  const circuits = [];

  async function walk(currentDir) {
    let entries;
    try {
      entries = await fs.readdir(currentDir, { withFileTypes: true });
    } catch (error) {
      if (error && error.code === "ENOENT") {
        return;
      }
      throw error;
    }

    const sortedEntries = entries.sort((a, b) => a.name.localeCompare(b.name));

    for (const entry of sortedEntries) {
      const entryPath = path.join(currentDir, entry.name);
      if (entry.isDirectory()) {
        await walk(entryPath);
        continue;
      }

      if (entry.isFile() && entry.name.endsWith(CIRCOM_EXTENSION)) {
        circuits.push(entryPath);
      }
    }
  }

  await walk(rootDir);
  return circuits;
}

function determineConcurrency(rawValue, taskCount) {
  const cpuCount =
    typeof os.availableParallelism === "function"
      ? os.availableParallelism()
      : Math.max(os.cpus()?.length ?? 1, 1);
  const defaultWorkers = Math.max(1, Math.min(cpuCount, taskCount || cpuCount));

  if (rawValue === undefined || rawValue === true) {
    return defaultWorkers;
  }

  const parsed = Number.parseInt(rawValue, 10);
  if (!Number.isFinite(parsed) || parsed <= 0) {
    console.warn(
      `Invalid value for --jobs ('${rawValue}'). Using default of ${defaultWorkers}.`
    );
    return defaultWorkers;
  }

  return Math.max(1, Math.min(parsed, taskCount || parsed));
}

async function resolveSnarkjsBinary(override) {
  const candidates = [
    override,
    process.env.SNARKJS_BIN,
    path.join(__dirname, "../node_modules/.bin/snarkjs"),
    path.join(__dirname, "../node_modules/.bin/snarkjs.cmd"),
    path.join(__dirname, "../bin/snarkjs"),
    "snarkjs",
  ].filter(Boolean);

  for (const candidate of candidates) {
    if (candidate === "snarkjs") {
      return candidate;
    }

    const resolvedCandidate = path.isAbsolute(candidate)
      ? candidate
      : path.resolve(__dirname, candidate);

    if (await pathExists(resolvedCandidate)) {
      return resolvedCandidate;
    }
  }

  throw new Error(
    "Unable to locate the snarkjs binary. Set SNARKJS_BIN, use --snarkjs, or install snarkjs globally."
  );
}

function normalizePath(targetPath) {
  return path.isAbsolute(targetPath)
    ? targetPath
    : path.resolve(process.cwd(), targetPath);
}

async function resolveInputPath({
  baseName,
  relativePath,
  outputDir,
  explicitInputDir,
}) {
  const relativeBase = relativePath.slice(0, -CIRCOM_EXTENSION.length);
  const relativeDir = path.dirname(relativeBase);

  const candidateRelativePaths = Array.from(
    new Set([
      `${relativeBase}.json`,
      `${relativeBase}.input.json`,
      path.join(relativeDir === "." ? "" : relativeDir, `${baseName}.json`),
      path.join(
        relativeDir === "." ? "" : relativeDir,
        `${baseName}.input.json`
      ),
      `${baseName}.json`,
      `${baseName}.input.json`,
    ])
  );

  const searchDirs = uniquePaths([
    explicitInputDir,
    path.join(outputDir, "inputs"),
    outputDir,
    path.join(BUILD_DIR, "inputs"),
    BUILD_DIR,
  ]);

  for (const directory of searchDirs) {
    for (const relativeCandidate of candidateRelativePaths) {
      const candidate = path.join(directory, relativeCandidate);
      if (await pathExists(candidate)) {
        return candidate;
      }
    }
  }

  return undefined;
}

function uniquePaths(paths) {
  const seen = new Set();
  const unique = [];

  for (const entry of paths) {
    if (!entry) {
      continue;
    }

    const absolute = normalizePath(entry);
    if (seen.has(absolute)) {
      continue;
    }

    seen.add(absolute);
    unique.push(absolute);
  }

  return unique;
}

function looksLikeJsonFile(value) {
  if (typeof value !== "string" || value.length === 0) {
    return false;
  }

  return path.extname(value).toLowerCase() === ".json";
}

async function run(command, args = [], options = {}, inheritIO = true) {
  return new Promise((resolve, reject) => {
    const spawnOptions = {
      stdio: inheritIO ? "inherit" : ["ignore", "pipe", "pipe"],
      ...options,
    };

    const child = spawn(command, args, spawnOptions);

    const collected = [];
    if (!inheritIO) {
      const collect = (chunk) => {
        const text = chunk.toString();
        for (const line of text.split(/\r?\n/)) {
          if (line.trim() !== "") {
            collected.push(line);
          }
        }
      };

      if (child.stdout) {
        child.stdout.on("data", collect);
      }
      if (child.stderr) {
        child.stderr.on("data", collect);
      }
    }

    child.on("error", reject);
    child.on("close", (code) => {
      if (code !== 0) {
        const error = new Error(
          `Command failed (${command} ${args.join(" ")}): exited with code ${code}`
        );
        error.code = code;
        error.output = collected;
        reject(error);
        return;
      }

      resolve({ code, output: collected });
    });
  });
}

async function processParallel(tasks, concurrency) {
  if (tasks.length === 0) {
    return;
  }

  const workerCount = Math.max(1, Math.min(concurrency, tasks.length));
  let nextIndex = 0;
  let failure;

  async function worker() {
    while (true) {
      if (failure) {
        return;
      }

      const currentIndex = nextIndex;
      nextIndex += 1;

      if (currentIndex >= tasks.length) {
        return;
      }

      try {
        await tasks[currentIndex]();
      } catch (error) {
        if (!failure) {
          failure = error;
        }
        return;
      }
    }
  }

  await Promise.all(Array.from({ length: workerCount }, () => worker()));

  if (failure) {
    throw failure;
  }
}